game has velocity based movement
next step, add collision check inside input handler

implement position arguments for entities


1. Collision Detection

Define Bounding Boxes:

    Ensure all entities with hitboxes have left, right, top, bottom edges derived from their position and size.

Predict Next Positions:

    Calculate the next position for moving entities using their current position and velocity.

Check for Overlap:

    Use axis-aligned bounding box (AABB) logic to detect overlaps between predicted positions.

Handle Static Objects:

    Include walls, floors, and other immovable objects in collision checks.

Resolve Collisions:

    Prevent movement or adjust position to stop entities just before collision.
    Reverse velocity if bouncing is required (e.g., velocityY = -velocityY * elasticity).

    Optimize Collision Checks:
        Implement directional checks (only check in the direction of movement).
        Consider spatial partitioning (grid or quadtree) for efficiency if there are many entities.

2. Physics System

Add Gravity:

    Apply a constant downward acceleration to all entities affected by gravity.

Integrate Velocity:

    Update velocity using acceleration:

    velocity += acceleration * dt

Update Position:

    Update position using velocity:

    position += velocity * dt

Apply Friction:

    Gradually reduce velocity to simulate resistance:

    velocity *= (1 - frictionCoefficient * dt)

Implement Bouncing:

    Reverse and scale velocity on collisions for bouncing effects:

    velocity = -velocity * elasticity

    Clamp Small Velocities:
        Set velocity to zero when it falls below a small threshold to avoid jittering.

3. Fixed-Point Arithmetic

Convert to Fixed-Point:

    Represent position, velocity, acceleration, and delta time as 16.16 fixed-point integers.

Use Scaled Operations:

    Scale multiplication and division results using bit shifts:

    result = (value1 * value2) >> 16

Precompute Constants:

    Store constants like GRAVITY and elasticity in 16.16 format during initialization.

Convert for Rendering:

    Convert fixed-point positions to integers for screen rendering:

        renderX = positionX >> 16

4. Delta Time Integration

Compute Delta Time:

    Measure the time elapsed between frames and convert to 16.16 format:

    dtFixed = (dt << 16) / 1000

Scale Time-Sensitive Calculations:

    Use dt to scale velocity, acceleration, and position updates:

        velocity += (acceleration * dt) >> 16
        position += (velocity * dt) >> 16

5. Testing and Tuning

Test Basic Movement:

    Verify that entities move correctly based on velocity updates.

Validate Collision Handling:

    Ensure entities stop moving or bounce when they collide with other entities or static objects.

Check Friction and Damping:

    Test how friction slows movement over time.

Simulate Bouncing:

    Validate that objects rebound correctly and eventually come to rest.

    Fine-Tune Parameters:
        Adjust constants like GRAVITY, elasticity, and frictionCoefficient for desired behavior.

6. Optimization (Future Steps)

Spatial Partitioning:

    Divide the game world into a grid or quadtree to reduce unnecessary collision checks.

Continuous Collision Detection:

    Implement swept AABB or similar algorithms for fast-moving objects.

    Advanced Features:
        Add sliding along surfaces or special interactions based on collision types.
