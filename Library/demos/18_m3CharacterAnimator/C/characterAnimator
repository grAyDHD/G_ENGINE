#include "../includes/characterAnimator.h"
#include "core/timer.h"
#include "graphics/video.h"
#include "input/in.h"

#define chocoboX chocobo.coordinate.x
#define chocoboY chocobo.coordinate.y
#define playerX player.coordinate.x
#define playerY player.coordinate.y

typedef enum { false = 0, true = !false } bool;
extern void SpriteFrame32(Character *character);

/*
const void *spriteSheets[NUM_STATES] = {
    idleSpriteSheet,
    walkingSpriteSheet,
    talkingSpriteSheet
};

void updateSpriteSheet(Character *character) {
    character->spriteSheet = spriteSheets[character->state];
}

void renderCharacter(const Character *character) { const void
*currentSpriteSheet = character->spriteSheet; int offset = character->frame +
character->direction * framesPerDirection; const void *sprite = (const void
*)((uintptr_t)currentSpriteSheet + offset * frameSize);

    // Pass the sprite to the rendering function
    drawSprite(character->coordinate.x, character->coordinate.y, sprite);
}
*/

void initializeCharacterSprites(
    Character *character, const void *spriteSheets[NUM_STATES][NUM_DIRECTIONS]);

void updateCurrentSpriteSheet(Character *character);

void setCharacterState(Character *character, STATE state);

void setCharacterDirection(Character *character, DIRECTION direction);

void setCharacterStateAndDirection(Character *character, STATE state,
                                   DIRECTION direction);

void moveCharacter(Character *character);

int main() {
  DSPC = MODE3 | BG2;

  m3_Background(BedroomBitmap);

  Character chocobo = {
      .direction = RIGHT,
      .state = WALK,
      .coordinate = {80, 75},
  };

  Character player = {
      .direction = DOWN,
      .state = IDLE,
      .coordinate = {120, 120},
  };

  //  initializeCharacterSprites(&chocobo, chocoboSprites);
  //  initializeCharacterSprites(&player, silverGirlSprites);

  int chocoboStepCounter = 0;
  int playerStepCounter = 0;

  while (1) {
    updateKeys();
    VBLANK();

    // Start by erasing sprite
    clearSpriteFrame(playerX, playerY, 32, BedroomBitmap);

    // Handle player input
    if (keyDown(U)) {
      setCharacterStateAndDirection(&player, WALK, UP);

      // Prevent player from moving into the collision box from the bottom
      if (!(playerX + 32 > 80 && playerX < 128 && playerY - 4 < 107 &&
            playerY >= 107)) {
        moveCharacter(&player);
      }
    } else if (keyDown(D)) {
      setCharacterStateAndDirection(&player, WALK, DOWN);

      // Prevent player from moving into the collision box from the top
      if (!(playerX + 32 > 80 && playerX < 128 && playerY + 4 + 32 > 75 &&
            playerY + 32 <= 75)) {
        moveCharacter(&player);
      }
    } else if (keyDown(L)) {
      setCharacterStateAndDirection(&player, WALK, LEFT);

      // Prevent player from moving into the collision box from the right
      if (!(playerX - 4 < 128 && playerX >= 128 && playerY + 32 > 75 &&
            playerY < 107)) {
        moveCharacter(&player);
      }
    } else if (keyDown(R)) {
      setCharacterStateAndDirection(&player, WALK, RIGHT);

      // Prevent player from moving into the collision box from the left
      if (!(playerX + 4 + 32 > 80 && playerX + 32 <= 80 && playerY + 32 > 75 &&
            playerY < 107)) {
        moveCharacter(&player);
      }
    }

    SpriteFrame32Bit(playerX, playerY, playerStepCounter % 4,
                     player.currentSpriteSheet, 4);
    restoreFrameBackground(playerX, playerY, 32, BedroomBitmap);

    if (keyReleased(U) | keyReleased(D) | keyReleased(L) | keyReleased(R)) {
      setCharacterState(&player, IDLE);
      playerStepCounter = 0;
    } else if (player.state != IDLE) {
      playerStepCounter++;
    }

    // Chocobo logic

    clearSpriteFrame(chocoboX, chocoboY, 32, BedroomBitmap);
    if (chocobo.state == WALK) {
      moveCharacter(&chocobo);
    }

    SpriteFrame32(&chocobo);
    //    SpriteFrame32Bit(int x, int y, int frame, const void *image, int
    //    frameCount)

    restoreFrameBackground(chocoboX, chocoboY, 32, BedroomBitmap);
    chocoboStepCounter++;

    // handle chocobo direction change
    if (chocoboStepCounter >= 4) {
      chocoboStepCounter = 0;
      if (chocobo.direction == RIGHT) {
        setCharacterDirection(&chocobo, LEFT);
      } else {
        setCharacterDirection(&chocobo, RIGHT);
      }
    }

    simpleWait(30);
  }

  return 0;
}

//  chocobo starts facing right, x = 80 y = 75
//  4 steps 4 pixels each, 16 + 32 = 48 pixel wide box, 32 tall
//  player can not enter box (80,75), (80, 107), (128,75), (128,107)

void initializeCharacterSprites(
    Character *character,
    const void *spriteSheets[NUM_STATES][NUM_DIRECTIONS]) {
  for (int state = 0; state < NUM_STATES; state++) {
    for (int direction = 0; direction < NUM_DIRECTIONS; direction++) {
      character->sprites.spriteSheets[state][direction] =
          spriteSheets[state][direction];
    }
  }

  character->currentSpriteSheet =
      character->sprites.spriteSheets[character->state][character->direction];
};

void updateCurrentSpriteSheet(Character *character) {
  character->currentSpriteSheet =
      character->sprites.spriteSheets[character->state][character->direction];
}

void setCharacterState(Character *character, STATE state) {
  character->state = state;
  updateCurrentSpriteSheet(character);
}

void setCharacterDirection(Character *character, DIRECTION direction) {
  character->direction = direction;
  updateCurrentSpriteSheet(character);
}

void setCharacterStateAndDirection(Character *character, STATE state,
                                   DIRECTION direction) {
  character->state = state;
  character->direction = direction;
  updateCurrentSpriteSheet(character);
}

void moveCharacter(Character *character) {
  switch (character->direction) {
  case RIGHT:
    character->coordinate.x += 4;
    break;
  case LEFT:
    character->coordinate.x -= 4;
    break;
  case UP:
    character->coordinate.y -= 4;
    break;
  case DOWN:
    character->coordinate.y += 4;
    break;
  }
}

Step 1: Define the InputComponent

The InputComponent should encapsulate the behavior of an input-handling entity. For simplicity, it could include:

    A function pointer for custom behavior.
    Predefined key bindings.

Example:

typedef struct {
    void (*handleInput)(EntitySystem* system, int entityId); // Custom behavior
} InputComponent;

This allows you to define unique input behavior for different entities by specifying a custom handleInput function.
Step 2: Refactor Entity Management

Add an InputComponent array to your ComponentManager. This aligns with your ECS design:

typedef struct {
    PositionComponent position[MAX_ENTITIES];
    VelocityComponent velocity[MAX_ENTITIES];
    AnimationComponent animation[MAX_ENTITIES];
    SpriteComponent sprite[MAX_ENTITIES];
   InputComponent input[MAX_ENTITIES]; // InputComponent added
} ComponentManager;

Update createEntity to initialize entities with an input-enabled flag:

int createEntity(EntitySystem* system, int componentMask) {
    if (system->nextEntityId >= system->maxEntities) {
        return -1; // Error: No more entities can be created
    }

    Entity* entity = &system->entities[system->nextEntityId];
    entity->entityID = system->nextEntityId;
    entity->componentMask = componentMask;

    // Initialize components if the corresponding flag is set
    if (componentMask & COMPONENT_POSITION) {
        system->world->position[entity->entityID] = (PositionComponent){120, 120};
    }
    if (componentMask & COMPONENT_INPUT) {
        // Add to inputEntities list for quick iteration
        system->inputEntities[system->inputEntityCount++] = entity->entityID;
    }

    return system->nextEntityId++;
}

Step 3: Simplify Input Handling

The updateInputSystem should loop through the inputEntities list and delegate input handling to each entity’s InputComponent.

void updateInputSystem(EntitySystem* system) {
    for (int i = 0; i < system->inputEntityCount; i++) {
        int entityId = system->inputEntities[i];
        InputComponent* input = &system->world->input[entityId];

        // Call the entity's custom input handler
        if (input->handleInput) {
            input->handleInput(system, entityId);
        }
    }
}

Step 4: Define Custom Input Behaviors

You can define custom input behavior functions for entities. For example, the player’s input handler:

void handlePlayerInput(EntitySystem* system, int entityId) {
    PositionComponent* position = &system->world->position[entityId];
    AnimationComponent* animation = &system->world->animation[entityId];

    if (keyDown(U)) {
        position->y -= 1;
        animation->state = WALK;
        animation->direction = UP;
    } else if (keyDown(D)) {
        position->y += 1;
        animation->state = WALK;
        animation->direction = DOWN;
    } else if (keyDown(L)) {
        position->x -= 1;
        animation->state = WALK;
        animation->direction = LEFT;
    } else if (keyDown(R)) {
        position->x += 1;
        animation->state = WALK;
        animation->direction = RIGHT;
    } else {
        animation->state = IDLE;
    }
}

When creating the player entity, assign this function to its InputComponent:

int createPlayer(EntitySystem* system, const void* spriteSheet) {
    int playerId = createEntity(system, COMPONENT_POSITION | COMPONENT_INPUT | COMPONENT_ANIMATION);

    system->world->sprite[playerId] = (SpriteComponent){.spriteSheet = spriteSheet};
    system->world->animation[playerId] = (AnimationComponent){.state = IDLE};
    system->world->input[playerId] = (InputComponent){.handleInput = handlePlayerInput};

    return playerId;
}

Main Game Loop

Finally, your game loop becomes cleaner:

int main() {
    DSPC = MODE3 | BG2;

    initEntitySystem(&entitySystem, &world, entities, MAX_ENTITIES);
    int playerId = createPlayer(&entitySystem, RoboBitmap);

    while (1) {
        updateKeys();  // Update GBA input state
        VBLANK();

        clearSpriteFrame(world.position[playerId].x, world.position[playerId].y, 32, BedroomBitmap);

        updateInputSystem(&entitySystem); // Process input for all input-enabled entities
        renderPlayer(&entitySystem, playerId);
    }

    return 0;
}

Advantages of This Design

    Modularity: Input logic is encapsulated within InputComponent and custom handler functions.
    Scalability: Easily add new entities with unique input behavior by defining new handleInput functions.
    Performance: Iterate only over inputEntities, avoiding unnecessary checks.
    Clarity: The updateInputSystem function is simple and delegates behavior cleanly.

This structure ensures a clean, readable, and extensible integration of input handling into your ECS.
You said:
Ah so the input component will contain a pointer to a function that will define an entities input behavior?  so I can create as many unique input handling functions for different scenarios, even changing the players input mechanics for different gameplay.  How can I align this input flexibility with the ecs in a way that has easily changeable input behavior, do I just create unique functions for different sets of behavior?  Is there a simple way to organize this?
ChatGPT said:
GPT Icon

Yes, the approach of having the InputComponent contain a function pointer provides significant flexibility to define and modify input behavior dynamically. You can use this mechanism to create distinct input behaviors for different entities or gameplay scenarios. Below is a deeper look into how to structure and organize this system effectively within your ECS.
Dynamic and Flexible Input Behavior
1. Unique Functions for Different Behaviors

You can create multiple input handler functions for different gameplay scenarios or entity types. For example:

    Player Movement:

void handlePlayerMovement(EntitySystem* system, int entityId);

Menu Navigation:

void handleMenuInput(EntitySystem* system, int entityId);

Interactive Objects:

    void handleObjectInteraction(EntitySystem* system, int entityId);

When the behavior needs to change (e.g., switching from gameplay to a menu), you simply update the handleInput function pointer in the InputComponent of the relevant entity.
2. Organizing Input Handlers

To keep your code organized:

    Group related functions into modules or files. For example:
        player_input.c for player-specific input behaviors.
        menu_input.c for menu-specific behaviors.
        npc_input.c for NPC or AI-controlled entity behaviors.
    Use meaningful naming conventions for input handlers, such as handlePlayerCombatInput or handleMenuSelectInput.

3. Dynamically Changing Input Behavior

You can change an entity’s input behavior by simply swapping its handleInput function. This is particularly useful for gameplay transitions.

Example: Switching Player Input Mode

void switchToCombatMode(EntitySystem* system, int playerId) {
    system->world->input[playerId].handleInput = handlePlayerCombatInput;
}

void switchToExplorationMode(EntitySystem* system, int playerId) {
    system->world->input[playerId].handleInput = handlePlayerMovement;
}

4. Using Behavior Tables for Organization

If you have many predefined behaviors, consider using a lookup table or registry to make behavior assignment easier.

Example: Input Behavior Registry

typedef enum {
    INPUT_BEHAVIOR_PLAYER_MOVEMENT,
    INPUT_BEHAVIOR_PLAYER_COMBAT,
    INPUT_BEHAVIOR_MENU_NAVIGATION,
    // Add more behaviors as needed
} InputBehaviorType;

typedef void (*InputHandler)(EntitySystem*, int);

InputHandler inputBehaviorTable[] = {
    handlePlayerMovement,      // INPUT_BEHAVIOR_PLAYER_MOVEMENT
    handlePlayerCombatInput,   // INPUT_BEHAVIOR_PLAYER_COMBAT
    handleMenuInput            // INPUT_BEHAVIOR_MENU_NAVIGATION
};

You can assign behaviors dynamically:

void setEntityInputBehavior(EntitySystem* system, int entityId, InputBehaviorType behaviorType) {
    system->world->input[entityId].handleInput = inputBehaviorTable[behaviorType];
}

Usage:

setEntityInputBehavior(system, playerId, INPUT_BEHAVIOR_PLAYER_MOVEMENT);
setEntityInputBehavior(system, menuEntityId, INPUT_BEHAVIOR_MENU_NAVIGATION);

5. Simplifying Behavior Assignment with Helper Functions

To avoid repetitive code, write helper functions for common scenarios:

    Assigning the same behavior to multiple entities:

    void assignBehaviorToEntities(EntitySystem* system, int* entityIds, int count, InputBehaviorType behaviorType) {
        for (int i = 0; i < count; i++) {
            setEntityInputBehavior(system, entityIds[i], behaviorType);
        }
    }

Runtime Flexibility

In gameplay, this design allows:

    Dynamic Changes: Swap input behaviors at runtime (e.g., during cutscenes, boss fights, or puzzles).
    Modular Extensions: Add new behaviors without modifying existing input logic.
    Debugging Tools: Create a "debug input behavior" for testing specific game features.

Example Workflow

Here’s how it might look in practice:
Create Entities with Default Behaviors

int playerId = createPlayer(system, playerSpriteSheet);
setEntityInputBehavior(system, playerId, INPUT_BEHAVIOR_PLAYER_MOVEMENT);

int menuId = createEntity(system, COMPONENT_INPUT);
setEntityInputBehavior(system, menuId, INPUT_BEHAVIOR_MENU_NAVIGATION);

Update Input System

void updateInputSystem(EntitySystem* system) {
    for (int i = 0; i < system->inputEntityCount; i++) {
        int entityId = system->inputEntities[i];
        InputComponent* input = &system->world->input[entityId];

        if (input->handleInput) {
            input->handleInput(system, entityId);
        }
    }
}

Change Behavior Dynamically

if (playerEntersCombatZone) {
    switchToCombatMode(system, playerId);
}

if (playerExitsCombatZone) {
    switchToExplorationMode(system, playerId);
}

Organizing Your Project

For maintainability:

    File Structure:
        input/: For all input-related modules.
            input/player_input.c
            input/menu_input.c
            input/npc_input.c
    Registry for Behaviors: A single header (input_behaviors.h) to declare all behavior types and the function pointer table.
    Documentation: Maintain a simple table or list documenting each InputBehaviorType and its associated function.

Final Thoughts

This approach aligns with ECS principles while remaining flexible for dynamic gameplay changes. By using function pointers and registries, you can keep your input system modular, extensible, and easy to maintain.


New version of GPT available
