

Limitations of Standard Arithmetic

    Lack of Precision:
        Small movements (e.g., 0.1 pixels/frame) are impossible with integers, leading to choppy or unrealistic motion.

    Scaling Issues:
        When frame rates or delta time (dt) are introduced, scaling velocity and acceleration becomes inaccurate with integer math.

Introducing Fixed-Point Math

Why Fixed-Point?

    Fixed-point arithmetic combines the precision of fractional values with the performance of integer math, making it ideal for GBA hardware.

How Fixed-Point Math Works

    Representation:
        A fixed-point number uses an integer to represent both integer and fractional parts:
            Example: 16.16 format splits a 32-bit integer into:
                Upper 16 bits for the integer part.
                Lower 16 bits for the fractional part.

    Operations:
        Addition/Subtraction: Operate as usual.
        Multiplication: Multiply and shift right by 16 to maintain precision.
        Division: Shift left by 16 before dividing.

    Conversion:
        Integer to Fixed-Point: fixed = int << 16
        Fixed-Point to Integer: int = fixed >> 16

Benefits of Fixed-Point Math

    Precision for Small Movements:
        Movements like 0.1 pixels/frame are represented as 655 (in 16.16 format).

    Consistent Scaling:
        Applying delta time (dt) scales velocity and acceleration accurately.

    Performance:
        Faster and more predictable than floating-point math on GBA.

Understanding and Applying 16.16 Fixed-Point Arithmetic

To effectively implement and use 16.16 fixed-point arithmetic, it's essential to break it down conceptually. Here's a structured explanation of how it works and how to apply it in your game physics or other calculations.
1. What Is Fixed-Point Arithmetic?
Concept

Fixed-point arithmetic stores numbers in a format where part of the bits represent the integer portion, and part represent the fractional portion. In a 16.16 format:

    The upper 16 bits (most significant bits) represent the integer part.
    The lower 16 bits (least significant bits) represent the fractional part.

Why Use It?

    It allows for fractional precision (e.g., 0.5) while using integer math, which is faster and more predictable on platforms like the GBA.
    Unlike floating-point numbers, it avoids the need for a floating-point unit (FPU), saving computation time and memory.

2. Visualizing 16.16 Fixed-Point Numbers
Structure

    A 32-bit integer (e.g., int32_t) is divided into two 16-bit parts:

    [Integer Part (16 bits)][Fractional Part (16 bits)]

Examples

    1.0 is represented as:

Integer Part = 1 (00000000 00000001)
Fractional Part = 0 (00000000 00000000)
Fixed-Point = 0x00010000 (65536 in decimal)

0.5 is represented as:

Integer Part = 0 (00000000 00000000)
Fractional Part = 0.5 * 2^16 = 32768 (10000000 00000000)
Fixed-Point = 0x00008000

-1.25 is represented as:

    Integer Part = -1 (11111111 11111111)
    Fractional Part = -0.25 * 2^16 = -16384 (11111111 11000000)
    Fixed-Point = 0xFFFFC000

Key Idea

    Multiplying a fractional value (e.g., 0.5) by 2^16 shifts it into the fractional part.
    Dividing by 2^16 shifts it back into the integer space.

3. Basic Operations
Addition and Subtraction

    These operations work just like standard integer arithmetic because the fixed-point format aligns the integer and fractional parts.
    Why: The fixed-point structure ensures that all numbers are in the same "scale."

Multiplication

    Multiplying two fixed-point numbers produces a result with twice the fractional bits (16.32 format).
    To return to 16.16 format, shift the result right by 16 bits.

    result = (fixed1 * fixed2) >> 16

    Why: This scaling ensures the fractional part remains correctly aligned.

Division

    Dividing two fixed-point numbers involves shifting the numerator left by 16 bits before dividing.

    result = (fixed1 << 16) / fixed2

    Why: This scaling preserves the fractional precision during division.

4. Converting Between Fixed-Point and Integer
To Fixed-Point

    Multiply the integer by 2^16 (or bit-shift left by 16):

    fixed = integer << 16

    Why: Shifting aligns the integer part with the fixed-point format.

To Integer

    Divide the fixed-point number by 2^16 (or bit-shift right by 16):

    integer = fixed >> 16

    Why: Shifting discards the fractional part, leaving the integer portion.

To Fractional Value

    Extract the fractional part by masking with 0xFFFF and dividing by 2^16:

    fractional = (fixed & 0xFFFF) / 65536.0

    Why: This isolates and normalizes the fractional part.

5. Applying Fixed-Point Math in Physics
Step 1: Represent Physics Components

    Store position, velocity, and acceleration as fixed-point numbers (int32_t in 16.16 format).

Step 2: Update Velocity with Acceleration

    Add the acceleration to the velocity:

    velocity += acceleration

    Why: Since all components are in 16.16 format, this works seamlessly.

Step 3: Update Position with Velocity

    Add the velocity to the position:

    position += velocity

    Why: The fixed-point format ensures sub-pixel precision.

Step 4: Render with Integer Values

    Convert the fixed-point position to an integer for rendering:

    renderX = positionX >> 16
    renderY = positionY >> 16

    Why: The renderer only needs integer values for screen coordinates.

6. Examples of Fixed-Point in Practice
Gravity

    Gravity is a small, constant downward acceleration (e.g., 0.1 pixels/frameÂ²).
    Represent as fixed-point:

GRAVITY = 0.1 * 65536 = 6554 (in 16.16 format)

Apply gravity to vertical velocity:

    velocityY += GRAVITY

Delta Time

    If dt is in milliseconds, convert to fixed-point:

dtFixed = (dt << 16) / 1000

Scale velocity or position updates by dt:

    velocity += (acceleration * dtFixed) >> 16
    position += (velocity * dtFixed) >> 16

    Why: Delta time ensures consistent physics across variable frame rates.

7. Common Pitfalls and How to Avoid Them

    Precision Loss
        Fixed-point math sacrifices precision for large numbers.
        Solution: Keep values within reasonable ranges (e.g., avoid extremely large positions or velocities).

    Overflow
        Multiplication or addition can exceed the 32-bit limit.
        Solution: Use clamping or limit values to safe ranges.

    Truncation
        Right shifts discard fractional values, leading to small errors.
        Solution: Be mindful of cumulative errors in repeated operations.

8. Summary of Steps to Implement Fixed-Point

    Understand the Format:
        Remember that 16.16 represents numbers with integer and fractional parts.

    Conversion:
        Convert between integers and fixed-point using shifts (<< 16, >> 16).

    Basic Operations:
        Use standard arithmetic for addition/subtraction.
        Scale results with shifts for multiplication/division.

    Physics Application:
        Store position, velocity, and acceleration as 16.16.
        Update velocity with acceleration.
        Update position with velocity.
        Convert to integers for rendering or collision checks.

    Test and Optimize:
        Validate calculations with small, controlled examples.
        Optimize operations where precision or performance is critical.
