// Struct to hold cursor cache data
typedef struct {
    Coordinate pos;          // Current cursor position
    u16 pixels[4][4];       // Cache for pixels under cursor (16-bit colors)
    bool hasCache;          // Whether cache contains valid data
} CursorCache;

// Save current pixels under cursor to cache
void saveToCursorCache(CursorCache* cache, Coordinate pos) {
    for(int y = 0; y < 4; y++) {
        for(int x = 0; x < 4; x++) {
            // Access VRAM directly using position offsets
            cache->pixels[y][x] = VRAM[pos.y + y][pos.x + x];
        }
    }
    cache->pos = pos;
    cache->hasCache = true;
}

// Restore pixels from cache to screen
void restoreFromCursorCache(CursorCache* cache) {
    if (!cache->hasCache) return;
    
    for(int y = 0; y < 4; y++) {
        for(int x = 0; x < 4; x++) {
            VRAM[cache->pos.y + y][cache->pos.x + x] = cache->pixels[y][x];
        }
    }
}

// Modified main loop implementation
int main() {
    DSPC = MODE3 | BG2;
    fillScreen(brushColor);
    enum MODE appState = DRAWING;
    Coordinate cursor = {0, 0};
    CursorCache cache = {0};  // Initialize cache
    
    while (1) {
        updateKeys();
        VBLANK();
        
        switch (appState) {
        case (DRAWING): {
            // Store old cursor position for comparison
            Coordinate oldCursor = cursor;
            
            // Update cursor position
            updateBrushPosition(&cursor);
            
            // If cursor moved, restore old pixels first
            if (oldCursor.x != cursor.x || oldCursor.y != cursor.y) {
                restoreFromCursorCache(&cache);
                
                // Handle drawing if A or B was held while moving
                if (keyHeld(A)) {
                    fillSquare(oldCursor, eraseColor);
                } else if (keyHeld(B)) {
                    fillSquare(oldCursor, brushColor);
                }
            }
            
            // Save pixels under new cursor position
            saveToCursorCache(&cache, cursor);
            
            // Draw at current position based on input
            if (keyHeld(A)) {
                fillSquare(cursor, eraseColor);
            } else if (keyHeld(B)) {
                fillSquare(cursor, brushColor);
            } else {
                fillSquare(cursor, eraseColor);  // Draw cursor
            }
            break;
        }
        case (COLOR):
            break;
        case (SHAPE):
            break;
        }
    }
    return 0;
}
