#ifndef MODPLAYER_H
#define MODPLAYER_H

#include "../data/dataSndData.h"
#include "audio/audio.h"
#include "audio/mixer.h"
#include "core/dma.h"
#include "core/interrupts.h"
#include "core/timer.h"
#include "core/typedefs.h"
#include "gba.h"
#include "graphics/video.h"
#include "input/in.h"

// ----- Constants -----

#define MOD_MAX_CHANNELS 4
#define TUT_BUFFER_SIZE 304

// For patterns to specify that there is no note. We have 5 octaves,
// so only notes 0-59 are used, and 63 is the highest that still fits
// in the same number of bits
#define MOD_NO_NOTE 63
// Valid samples are 0-30, use 31 as a blank to fit in 5 bits
#define MOD_NO_SAMPLE 31

typedef enum _MOD_STATE {
  MOD_STATE_STOP,
  MOD_STATE_PLAY,
  MOD_STATE_PAUSE,
} MOD_STATE;

// ----- Structures -----

typedef struct {
  const s8 *data;
  u32 pos;
  u32 inc;
  u32 vol;
  u32 length;
  u32 loopLength;
} ModMixerChannel;

typedef struct __attribute__((packed)) {
  union {
    struct {
      s8 bufA[TUT_BUFFER_SIZE];
      s8 bufB[TUT_BUFFER_SIZE];
    };
    s8 bufBase[TUT_BUFFER_SIZE * 2];
  };
  ActiveBuffer activeBuffer;
  s8 *position;
} Mixbuf;

typedef struct {
  u16 mixFreq;
  u16 rcpMixFreq;
  s16 samplesUntilMODTick;
  u16 samplesPerMODTick;
} ModTiming;

// This is the layout of the sample info in ROM
typedef struct {
  u16 length;
  u8 finetune;
  u8 vol;
  u16 loopStart;
  u16 loopLength;

  const s8 *smpData; // Pointer to sample data in ROM

} SampleHeader;

// This is the MOD data layout in ROM
typedef struct _MOD_HEADER {
  const SampleHeader *sample;
  const u8 *order;
  const u8 **pattern;

  u8 orderCount;
  u8 pad[3];

} ModHeader;

// This is the data we need to keep track of for each channel
// while playing the song, stored in RAM
typedef struct {
  u32 frequency; // Current frequency of note being played, in Hz

  u8 sample; // Last sample used on this channel
  u8 vol;    // Current volume

  u8 pad[2]; // Align to 4 bytes

} ModChannel;

// This is all the data for the currently playing song, in RAM
typedef struct {
  const SampleHeader *sample; // Pointer to table of samples in ROM
  const u8 **pattern;         // Pointer to table of pointers to patterns
  const u8 *order;            // Array of pattern numbers to play

  const u8 *rowPtr; // Current position in current pattern, for quick access

  u8 state; // MOD_STATE enum (stopped/playing/paused)

  u8 speed;
  u8 tick; // When this gets to speed, process a new row and reset it to 0

  u8 curRow; // When this gets to 64, move to the next order and reset to 0

  u8 orderCount;
  u8 curOrder; // When this gets to orderCount, stop the song

  u8 tempo; // In BPM (Hz = BPM*2/5)

  u8 pad;

  ModChannel channel[MOD_MAX_CHANNELS]; // Current state of each channel

} ModPlayer;

// ----- Global vars -----

extern ModMixerChannel modMixerChannel[MOD_MAX_CHANNELS];
// extern ModMixer modMixer;
extern Mixbuf mbuf;
extern ModTiming modTiming;
extern ModPlayer modPlayer;

// ----- Tables generated by converter (in SndData.c) -----

extern const ModHeader dModTable[];
extern const SampleHeader dSfxTable[];

// ----- Global functions -----

extern void SndInit();
extern void SndVSync(); // IN_IWRAM; // in Irq.c
extern void SndMix(u32 samplesToMix);
extern void SndUpdate();

extern void SndPlayMOD(u32 modIdx);

extern void MODUpdate();

#endif
